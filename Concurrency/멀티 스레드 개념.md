# 멀티 스레드
## 프로세스와 스레드
- 프로세스(process) : 실행 중인 하나의 애플리케이션
  - 운영체제로부터 실행에 필요한 메모리를 할당받아 애플리케이션의 코드를 실행하는 것
- 스레드(Thread) : 한 가지 작업을 실행하기 위한 코드의 흐름
- 멀티 태스킹(Multi Tasking) :
  - 두 가지 작업을 동시에 처리하도록 운영체제가 CPU/메모리 자원을 프로세스 마다 적절히 할당하고 병렬로 실행시키는 것
  - 애플리케이션 단위의 멀티 태스킹
  - 운영체제에서 할당받은 자신의 메모리를 가지고 실행하기 때문에 독립적이고, 하나의 프로세스에서 오류가 발생해도 다른 프로세스에게 영향을 미치지 않는다
- 멀티 스레드(Multi Thread) :
  - 하나의 프로세스가 두 가지 이상의 작업을 처리하는 것
  - 애플리케이션 내부에서의 멀티 태스킹 
  - 멀티 스레드는 하나의 프로세스 내부에 생성되기 때문에 하나의 스레드가 예외를 발생시키면 프로세스가 종료될 수 있어 다른 스레드에게도 영향을 미친다.

### 메인 스레드 
- 모든 자바 어플리케이션은 메인 스레드가 main()메소드를 실행하면서 시작되고, 싱글 스레드는 모든 작업이 끝나 메인 스레드가 종료되면 프로세스도 종료된다.
- 하지만 멀티 스레드는 메인 스레드가 종료되어도 실행중인 다른 작업 스레드가 있다면 프로세스는 종료되지 않는다.

## 작업 스레드 생성과 실행
- 멀티 스레드를 실행하는 애플리케이션을 개발하려면 **몇 개의 작업**을 병렬로 실행할지 결정하고 각 작업별로 **스레드를 생성**해야한다.
- 자바에서는 작업 스레드도 객체로 생성되기 때문에 클래스가 필요하다.
  - java.lang.Thread 클래스를 객체화해서 새로 생성하거나,  Thread를 상속한 하위 클래스를 만들어서 생성할 수 도 있다.
 
### Thread 클래스로부터 직접 생성
- Runnable : 작업 스레드가 실행할 수 있는 코드를 가지고 있는 객체, 인터페이스 타입이라서 구현 객체를 만들어 대입해야 하는데 이 때 람다식을 많이 사용한다.
  - run()메소드 하나가 정의되어 있는데 구현 클래스는 run()을 재정의해서 스레드가 실행할 코드를 작성한다.
  - Runnable은 작업 내용을 가지고 있는 객체이며 실제 스레드는 아니다. Runnable객체를 매개값으로 받는 Thread 객체를 생성해야 작업 스레드가 생성이된다.
  - 작업 스레드는 생성 즉시 실행되지 않고 start()메소드를 호출해야 비로소 실행된다.  
```java
Thread thread = new Thread(() -> {
    // run 메소드 재정의
})
thread.start(); // 실행 시작
```
### Thread 하위 클래스로부터 생성
Thread를 상속받는 새로운 하위 클래스를 생성해서 이를 실행한다.
``` java
public class WorkerThread extends Thread {
  @Override
  public void run() {
      
  }
}

Thread worker = new WorkerThread();
worker.start();
```
## 스레드의 우선순위
- Concurrency(동시성) : 멀티 작업을 위해 *하나의 코어*에서 멀티 스레드가 **번갈아가며** 실행하는 설질
- Parallelism(병렬성) : 멀티 작업을 위해 *멀티 코어*에서 개별 스레드를 **동시에 실행**하는 성질
- 스레드 스케쥴링 : 스레드의 개수 > 코어의 개수일 경우, 스레드를 어떤 순서에 의해 동시성으로 실행할 것인지를 결정하는 것
  - 스레드들은 스레드 스케쥴링에 의해 아주 짧은 시간에 번갈아가면서 각자의 run() 메소드들을 수행한다.
  - Priority 우선순위 방식 : 우선순위가 높은 스레드가 실행 상태를 더 많이 가지도록 스케쥴링 하는 것 -> 개발자가 우선순위를 설정해서 제어가능
  - Round Robin 순환 할당 방식 : 시간 할당량(Time Slice)를 정해서 하나의 스레드를 정해진 시간만큼 실행하고 다시 다른 스레드를 실행하는 방식 -> JVM이 제어

## 동기화 메소드와 동기화 블록
### 공유객체를 사용할 때의 주의점
싱글 스레드 프로그램에서는 하나의 스레드가 객체를 독차지 하지만, 멀티 스레드 프로그램에서는 스레드들이 객체를 공유해서 작업하기 때문에 내가 작업하고 있던 객체가 작업도중 다른 스레드에 의해 상태가 변경될 수 있다. 

### synchronized 메소드 및 블록
스레드가 사용중인 객체를 다른 스레드가 변경할 수 없도록 하려면 스레드 작업이 끝날 때까지 객체에 잠금을 걸어서 다른 스레드가 사용할 수 없도록 해야 한다. 
- Critical Section(임계 영역) : 멀티 스레드 프로그램에서 단 하나의 스레드만 실행할 수 있는 코드 영역
  - 자바에서는 critical section을 지정하기 위해 synchronized 메소드와 블록을 제공함.
- Synchronized :
  - 스레드가 객체 내부의 동기화 메소드 혹은 블로겡 들어가면 즉시 객체에 잠금을 걸어 다른 스레드가 이 코드를 실행하지 못하게 된다.
  - synchronized 키워드는 인스턴스나 정적 메소드 어디든 붙일 수 있다.
  - `동기화 메소드` : 메소드 전체 내용이 임계 영역이므로 스레드가 동기화 메소드를 실행하는 즉시 객체에 잠금이 일어나고, 스레드가 동기화 메소드를 종료하면 잠금이 해제된다. 이 때 다른 스레드는 일반 스레드만 접근 할 수 있다.
  -  `동기화 블록` : 스레드가 동기화 블록으로 들어가며 this 객체를 잠그고 동기화 블록을 실행한다.
 
## 스레드 상태 
|상태|스레드 객체 생성|→start()→|실행 대기| →→ |실행| →→ |종료|
|---|------------|---------|-------|----|---|---|----|
|   |   NEW      |         |RUNNABLE|   |RUNNING|  |TERMINATED|


## Spirng 서버에서는 어떻게 대용량 요청을 동시에 처리하는 걸까?
[How to handle incoming requests in Java with Spring Boot](https://medium.com/@burakkocakeu/how-to-handle-incoming-requests-in-java-with-spring-boot-b46cb35ed520)
스프링 프레임워크는 기본적으로 멀티 스레드로 설계되어 있다. 스프링 어플리케이션 서버 인스턴스가 하나일 때에도 내장된 웹 서버(예: 톰캣)는 스레드 풀을 사용하여 요청을 처리하고 이로써 스프링 어플리케이션은 동시에 여러 요청을 처리할 수 있습니다.   
일반적으로 스프링 어플리케이션은 여러 스레드로 요청을 동시에 처리하고, 이를 통해 성능을 향상시킴.  
스프링은 멀티 스레딩에 대한 복잡한 작업을 추상화하여 개발자가 쉽게 다룰 수 있도록 지원, 개발자는 멀티 스레드에 대한 고민없이 도메인 로직에 집중 가능

### @RestController
스프링부트의 @RestController어노테이션은 기본적으로 멀티 스레딩을 지원하지만, API를 작성할 때 Concurrency와 성능에 대한 고려가 필요하다.   
- @RestController 엔드포인트에 들어오는 각 요청은 새로운 스레드를 생성하고, 해당 엔드포인트는 이 스레드에서 실행된다
- 그러나 해당 엔드포인트를 수행하는 스레드에 DB 쿼리, Slow API Call 같이 블로킹 동작이 있을 경우, 지연되는 작업이 끝날 때까지 다른 요청을 처리하지 못하게 되 성능 저하가 일어난다.
- 이를 피하기 위해 @RestController 엔드포인트에서 비블로킹 코드를 작성하거나 Future, Callable 또는 Reactor 라이브러리와 같은 비동기 프로그래밍 기술을 사용하여 느린 작업이 완료될 때까지 스레드가 차단되지 않도록 해야한다.
- 또한, 여러 스레드가 공유 데이터 구조에 액세스할 때 발생할 수 있는 경쟁 조건이나 데드락과 같은 동시성 문제를 처리하는 것이 중요합니다. 데이터가 동시에 액세스될 때도 데이터가 일관되고 올바르게 유지되도록 잠금(lock) 또는 원자 변수(atomic variable)와 같은 적절한 동기화 기술을 사용

#### API 처리 전략
1. Synchronous 동기 처리: 엔드포인트 메소드는 동기적으로 실행되어 각 요청이 순서대로 처리됩니다. @RequestMapping 애노테이션을 메소드에 단순히 추가하면, 스프링 부트가 요청을 동기적으로 처리
2. Asyncronous 비동기 처리: 
  - 비동기적으로 실행되어 여러 요청을 동시에 처리
  - 엔드포인트 메소드에 @Async 애노테이션을 추가하면 해당 메소드는 별도의 스레드에서 실행, 일반 객체 대신 java.util.concurrent.CompletableFuture<T>를 반환
  -  비동기 작업은 요청을 보낸 후 결과를 기다리지 않고 다른 작업을 수행할 수 있다. 대신, 작업이 완료되면 결과를 얻을 수 있음
  - 주로 단일 스레드에서 이루어지며, 비동기 작업을 수행하는 스레드는 작업이 완료되기를 기다리지 않고 다른 작업을 수행
  - 스프링 부트가 요청을 비동기적으로 처리하며 스레드 풀을 사용합니다.
3. Concurrent handling 병렬 처리:
  - 엔드포인트 메소드는 병렬로 실행되어 여러 요청을 동시에 처리할 수 있습니다.
  - 병렬 처리는 멀티코어 시스템에서 여러 개의 코어를 최대한 활용하여 작업을 분산하고 실행함으로써 성능을 향상
  - 이를 구현하기 위해 설정 클래스에서 @EnableAsync와 @EnableScheduling 애노테이션을 사용하고, java.util.concurrent.Executor와 java.util.concurrent.ScheduledExecutorService를 사용
4. 로드 밸런서 사용: Nginx, HAProxy 또는 Amazon의 Elastic Load Balancer와 같은 로드 밸런서를 사용하여 들어오는 요청을 애플리케이션의 여러 인스턴스로 분산. 이를 통해 애플리케이션이 동시에 더 많은 요청을 처리할 수 있게 됩니다.




